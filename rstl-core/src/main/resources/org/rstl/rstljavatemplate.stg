group dtlclassgenerator;

javaclass(ctxt)::=<<

package <ctxt.packageName>;

/*********************************************************************
 * This file is automatically generated from a template, DO NOT CHANGE
 *********************************************************************/
 
import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.Stack;

import org.rstl.Constants;
import org.rstl.ForLoopCounter;
import org.rstl.SourceRef;
import org.rstl.TemplateGroup;
import org.rstl.ResourceRef;
import org.rstl.Template;
import org.rstl.context.TemplateContext;
import org.rstl.TemplateUtil;
import org.rstl.NullRef;
import org.rstl.VarUtil;


/*
 * This is a generated class
 */

/**
 * Generated class from template <ctxt.name>
 */
public class <ctxt.className> <if(ctxt.superClassName)>extends <ctxt.superClassName><endif> implements Template {
  final public static String TEMPLATE_NAME = "<ctxt.name>";
  final private static String PARENT_TEMPLATE_NAME = "<ctxt.superTemplateName>";
  <if(ctxt.layout)>
  final private static String LAYOUT_TEMPLATE_NAME = "<ctxt.layout.id>";
  <endif>
  final private static String RENDER_SUPER = "block.super";
  
  /*
   * CHUNK declarations
   */
  <ctxt.chunks:chunkdeftemplate()>
  final private static List\<SourceRef> MY_BLOCK_REFS = Arrays.asList(<ctxt.blocks:{new SourceRef("<it.id>", TEMPLATE_NAME, <it.line>)}; separator=", ">);
  final private static int CHUNK_COUNT = <length(ctxt.chunks)>;
  final private static List\<SourceRef> MY_RGROUP_REFS = Arrays.asList(<ctxt.rgroups:{new SourceRef("<it.id>", TEMPLATE_NAME, <it.line>, <it.declStart>, <it.declStop>)}; separator=", ">);
  final private static List\<SourceRef> MY_RESOURCE_REFS = Arrays.asList(<ctxt.resources:{new SourceRef("<it.id>", TEMPLATE_NAME, <it.line>)}; separator=", ">);
  final private static List\<String> MY_PRECONDITIONS = Arrays.asList(<ctxt.preconditions:{"<it>"}; separator=", ">);
  final private static List\<String> MY_INCLUDES = Arrays.asList(<ctxt.includes:{"<it>"}; separator=", ">);
  
  /*
   * The following variable includes references inherited from ancestors
   */
  final private static Set\<String> ALL_MY_BLOCKS = new TreeSet\<String>();
  final private static Set\<String> ALL_MY_RGROUPS = new TreeSet\<String>();
  
  private static Map\<String, String> blockMap = new HashMap\<String, String>();
  private static Map\<String, String> rgroupMap = new HashMap\<String, String>();
  private static Map\<String, String> chunkMap = new HashMap\<String, String>();
  private static Map\<String, SourceRef> rgroupSrcMap = new HashMap\<String, SourceRef>();
  
  // List of variables
  private static List\<String> varList = Arrays.asList(<ctxt.variables:{"<it>"}; separator=", ">);
  private static Map\<ResourceRef, ResourceRef> resRefMap = new HashMap\<ResourceRef, ResourceRef>();
    
  static {
    for (SourceRef blockRef : MY_BLOCK_REFS) {
      blockMap.put(blockRef.getName(), blockRef.getName() + "Block");
      ALL_MY_BLOCKS.add(blockRef.getName());
    }
    for (SourceRef rgroupRef: MY_RGROUP_REFS) {
      rgroupMap.put(rgroupRef.getName(), rgroupRef.getName() + "RGroup");
      rgroupSrcMap.put(rgroupRef.getName(), rgroupRef);
      ALL_MY_RGROUPS.add(rgroupRef.getName());
    }
    <ctxt.chunks:chunkmaptemplate(); separator="\n">
    <ctxt.resources:resourcemaptemplate(); separator="\n">
    <if(ctxt.superClassName)>
    	for (String name: <ctxt.superClassName>.getInstance().getBlockNames()) {
    		ALL_MY_BLOCKS.add(name);
    	}
    	for (String name: <ctxt.superClassName>.getInstance().getRGroupNames()) {
    		ALL_MY_RGROUPS.add(name);
    	}
    <endif>
  }
  
  private static <ctxt.className> instance = null;

  protected <ctxt.className>() {
  }
  
  public static <ctxt.className> getInstance() {
    if (null == instance) {
      instance = new <ctxt.className>();
    }
    return instance;
  }
  
  /*
   * Define the blocks for the template
   */
  <ctxt.blocks:blockdefinition(); separator="\n\n">
  
  /*
   * Define the rgroups for the template
   */
  <ctxt.rgroups:rgroupdefinition(); separator="\n\n">
  
  public void writeChunk(Writer w, String chunkName, String chunkStr) {
    try {
      w.append(chunkStr);
    } catch (IOException ioe) {
      System.out.println("Failed to write chunk :" + chunkName
            + " due to IOException: " + ioe);
    }
  }
  
  
  /**
   * Render the template using the context provided 
   * @param c 
   *        The template context 
   * @param w
   *        The writer to which the template will be rendered
   * @param includeTemplateMetadata
   *        If true, the rendered data will contain references to the template rendering the data. Use only for internal/debug apps
   */
  public void render(TemplateContext c, Writer w, boolean includeTemplateMetadata) {
    String layoutName = getLayoutTemplateName();
    Template layoutTemplate = null;
    if (null != layoutName) {
    	TemplateGroup tg = (TemplateGroup)c.get(Constants.TEMPLATE_GROUP);
    	if (null == tg) {
  			// Use reflection
  			try {
  				String className = TemplateUtil.getPackageName() + '.' + TemplateUtil.getClassName(layoutName);
				Class inclClass = Class.forName(className);
				Method getInstanceMethod = inclClass.getMethod("getInstance", null);
				Object obj = getInstanceMethod.invoke(null, null);
				layoutTemplate = (Template) obj;
			} catch (ClassNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (SecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchMethodException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalArgumentException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
  		} else {
  			layoutTemplate = tg.getTemplate(layoutName);
  		}
  	}
  	if (null == layoutTemplate && null != layoutName) {
  		System.err.println("Failed to locate layout template \"" + layoutName + "\"");
  	} 
  	if (null != layoutTemplate) {
  		// Render the included template
  		layoutTemplate.renderAsLayout((Template)this, c, w, includeTemplateMetadata);
  	} else {
  	    // Not being rendered as a layout template
 		renderAsLayout(null, c, w, includeTemplateMetadata);
  	} 	
  }
  
  /**
   * Render this template as a layout. This means that any block or rgroup definitions should first be resolved against the
   * main template before using the current (layout) template's definition
   *
   * @param mainTemplate
   *        The template that invoked this template as a layout template
   * @param c
   *        The template context
   * @param w
   *        The writer to which the template will be rendered
   * @param includeTemplateMetadata
   *        If true, the rendered data will contain references to the template rendering the data. Use only for internal/debug apps
   */         
  public void renderAsLayout(Template mainTemplate, TemplateContext c, Writer w, boolean includeTemplateMetadata) {
  	boolean inBlock = false;
  	// Stack used to maintain the context and local iterator keys
  	Stack forLoopKeys = new Stack();
  	Object origTemplate = c.get(Constants.TEMPLATEREF);
  	c.put(Constants.TEMPLATEREF, (null != mainTemplate) ? mainTemplate: this);
  	Iterable collection = null;
  	Object origVarValue = null;
    <if(ctxt.superClassName)>super.renderAsLayout(mainTemplate, c, w, includeTemplateMetadata);<\n><endif>
    // Render the contents of the main template
    <ctxt.main:{s | <s:(s.type)(inblock=ctxt.false, blockname=ctxt.false)>}; separator="\n">     
    if (null == origTemplate) {
    	c.remove(Constants.TEMPLATEREF);
    } else {
        c.put(Constants.TEMPLATEREF, origTemplate);
    }
  }
  
  /**
   * Invoke a specific method in this template. Used from layout templates to invoke blocks and rgroups
   * @param methodName
   * @param c
   * @param w
   * @param includeMetadata
   */
  public void invokeMethod(String methodName, TemplateContext c, Writer w, boolean includeMetadata) {
	// Use reflection
	// TODO: Cache method so that we do not have to recompute every time.
  	try {
		Class myClazz = this.getClass();
		Method getBlockRGroupMethod = myClazz.getMethod(methodName, Template.class, TemplateContext.class, Writer.class, boolean.class);
		Object obj = getBlockRGroupMethod.invoke(this, null, c, w, includeMetadata);
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalArgumentException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (InvocationTargetException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}	
  }
  
  private void renderIncludedTemplateOnce(String templateName, TemplateContext c, Writer w, boolean includeTemplateMetadata){
  	Set\<String> alreadyIncludedTemplates = (Set\<String>) c.get(Constants.TEMPLATES_INCLUDED);
  	if (alreadyIncludedTemplates.contains(templateName)) {
  		// Nothing to do
  		// May be log a debug message here
  	} else {
  		renderIncludedTemplate(templateName, c, w, includeTemplateMetadata);
  	}
  }
  
  /**
   * Render the included template with the current context
   */
  private void renderIncludedTemplate(String templateName, TemplateContext c, Writer w, boolean includeTemplateMetadata){
	TemplateGroup tg = (TemplateGroup)c.get(Constants.TEMPLATE_GROUP);
  	Set\<String> alreadyIncludedTemplates = (Set\<String>) c.get(Constants.TEMPLATES_INCLUDED);
  	alreadyIncludedTemplates.add(templateName);
	Template inclTemplate = null;
	if (null == tg) {
  		// Use reflection
  		try {
  				String className = TemplateUtil.getPackageName() + '.' + TemplateUtil.getClassName(templateName);
				Class inclClass = Class.forName(className);
				Method getInstanceMethod = inclClass.getMethod("getInstance", null);
				Object obj = getInstanceMethod.invoke(null, null);
				inclTemplate = (Template) obj;
			} catch (ClassNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (SecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchMethodException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalArgumentException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
  	} else {
  		inclTemplate = tg.getTemplate(templateName);
  	}
  	if (null == inclTemplate) {
  		System.err.println("Failed to locate template \"" + templateName + "\"");
  	} else {
  		// Render the included template
  		inclTemplate.render(c, w, includeTemplateMetadata);
  	}
  }
  
  public List\<String> getVariables() {
  	List\<String> retList = new ArrayList\<String>();
  	for (String l : varList) {
  		retList.add(l);
  	}
  	<if(ctxt.superClassName)>
  	for (String l : super.getVariables()) {
  		if (!retList.contains(l)) {
  			retList.add(l);
  		}
  	}
  	<endif>
  	return retList;
  }
  
  public Set\<SourceRef> getBlockRefs() {
    Set\<SourceRef> l = new TreeSet\<SourceRef>();
    for (SourceRef ref : MY_BLOCK_REFS) {
    	l.add(ref);
    }
    <if(ctxt.superClassName)>l.addAll(super.getBlockRefs());<endif>
    return l;
  }  
  
  public Set\<SourceRef> getRGroupRefs() {
  	Set\<SourceRef> l = new TreeSet\<SourceRef>();
  	for (SourceRef ref : MY_RGROUP_REFS) {
    	l.add(ref);
    }
  	<if(ctxt.superClassName)>l.addAll(super.getRGroupRefs());<endif>
  	return l;
  }
  
  public Set\<SourceRef> getResourceRefs() {
  	Set\<SourceRef> l = new TreeSet\<SourceRef>();
  	for (SourceRef ref : MY_RESOURCE_REFS) {
    	l.add(ref);
    }
  	<if(ctxt.superClassName)>l.addAll(super.getResourceRefs());<endif>
  	return l;
  }
  
  public Set\<String> getBlockNames() {
  	return <ctxt.className>.ALL_MY_BLOCKS;
  }
  
  public Set\<String> getRGroupNames() {
  	return <ctxt.className>.ALL_MY_RGROUPS;
  }
  
  public SourceRef getRGroupRef(String name) {
  	return rgroupSrcMap.get(name);
  }
  
  public List\<String> getPreconditions() {
  	return <ctxt.className>.MY_PRECONDITIONS;
  }
  
  public List\<String> getIncludes() {
  	return <ctxt.className>.MY_INCLUDES;
  }
  
  public String getSuperTemplateName() {
  	return <ctxt.className>.PARENT_TEMPLATE_NAME;
  }
  
  public String getLayoutTemplateName() {
  	String layoutName = null;
  	<if(ctxt.layout)>
  	layoutName = "<ctxt.layout.id>";
  	<else><if(ctxt.superClassName)>
  	layoutName = super.getLayoutTemplateName();
  	<endif><endif>
  	return layoutName; 
  }
  
  public String getTemplateName() {
    return <ctxt.className>.TEMPLATE_NAME;
  }
  
  private void push(Stack stack, String variableName, TemplateContext c) {
  	Object origVarValue = null;
	// Push the key in the context on to the stack
	origVarValue = c.get(variableName);
	if (null == origVarValue) {
 	  origVarValue = NullRef.getInstance();
	} 
	stack.push(origVarValue);
  }
  
  private void pop(Stack stack, String variableName, TemplateContext c) {
  	Object origVarValue = stack.pop();
	if (NullRef.getInstance() == origVarValue) {
  		c.remove(variableName);
	} else {
 		c.put(variableName, origVarValue);
	}
  }
  
  /**
   * Write a div with the specified id and style information
   */
  private void writeDivBegin(Writer w, String id, String[] styles) {
    try {
      w.append("\<div class=\"");
      w.append("rgroup_"+id);
      if (null != styles && styles.length > 0) {
      	for (String style: styles) {
      		w.append(" ").append(style);
      	}
      }
      w.append("\"");
      w.append(">");
      w.append("\<div class=\"rgroupname\">" + id + "\</div>");
    } catch (IOException ioe) {
      System.out.println("Failed to write div begin :" + id
            + " due to IOException: " + ioe);
    }
  }
  
  /**
   * Write a div end 
   */
  private void writeDivEnd(Writer w) {
    try {
      w.append("\</div>");
    } catch (IOException ioe) {
      System.out.println("Failed to write div end due to IOException: " + ioe);
    }
  }
  
}  
>>

chunkdeftemplate() ::= <<
final private static String CHUNK_<it.id> = "<it.value>";<\n>
>>

chunkmaptemplate() ::= <<
chunkMap.put("chunk_<it.id>", CHUNK_<it.id>);
>>

resourcemaptemplate() ::= <<
resRefMap.put(new ResourceRef("<it.id>", "<it.widgetName>", "<it.representationFormat>", "<it.variableName>"), new ResourceRef("<it.id>", "<it.widgetName>","<it.representationFormat>", "<it.variableName>"));
>>

blockdefinition() ::= <<
public void <it.id>Block(Template mainTemplate, TemplateContext c, Writer w, boolean includeTemplateMetadata) {
  boolean inBlock = true;
  // Stack used to maintain the context and local iterator keys
  Stack forLoopKeys = new Stack();
  Object origVarValue = null;
  Iterable collection = null;

  <it.statements:{s | <s:(s.type)(inblock=ctxt.true, blockname=it.id )>}; separator="\n">
}
>>

rgroupdefinition() ::= <<
public void <it.id>RGroup(Template mainTemplate, TemplateContext c, Writer w, boolean includeTemplateMetadata) {
  String[] styles = {"rgroup"};
  // Stack used to maintain the context and local iterator keys
  Stack forLoopKeys = new Stack();
  Object origVarValue = null;
  Iterable collection = null;
  writeDivBegin(w, "<it.id>",  styles);	
  <it.statements:{s | <s:(s.type)(inblock=ctxt.true, blockname=it.id)>}; separator="\n">
  writeDivEnd(w);
}
>>

chunkstatement(inblock, blockname) ::= <<
writeChunk(w, "CHUNK_<it.id>", CHUNK_<it.id>);
>>

forstatement(inblock, blockname) ::= <<
do {
// Push the key in the context on to the stack
push(forLoopKeys, "<it.key>", c);
push(forLoopKeys, "forloop", c);
ForLoopCounter fcounter<it.id> = new ForLoopCounter(c.getListSize("<it.collection>"), c.get("forloop"));
c.put("forloop", fcounter<it.id>);
for(Object key<it.id> : (Iterable) c.getList("<it.collection>")) {
  // Insert the local variables for use by the nested statements
  c.put("<it.key>", key<it.id>);
  <it.statements:{x | <x:(x.type)(inblock=inblock,blockname=blockname)>}; separator="\n">
  fcounter<it.id>.increment();
}

// Pop the original context values in reverse
pop(forLoopKeys, "forloop", c);
pop(forLoopKeys, "<it.key>", c);
}while(false);
>>

variablestatement(inblock, blockname) ::= <<
try {
  /*
  if ("<it.id>".equals(RENDER_SUPER)) {
  	<if(ctxt.superClassName)>
  	if (inBlock && super.getBlockNames().contains("<blockname>")) {
  		super.<blockname>Block();
  	}
	<endif>
  } else {*/
    w.append(<it.appliedFilterPrefixString>c.getString("<it.variableName>")<it.appliedFilterSuffixString>);
  //}
} catch (IOException ioe) {
  System.out
    .println("Failed to write variable <it.id> due to exception:" 
      + ioe);
}
>>

blockstatement(inblock, blockname) ::= <<
<if(!inblock)>
  <if(ctxt.superClassName)>
if (!super.getBlockNames().contains("<it.id>")) {
  // If super defines this block, then this template is simply overriding
  // this block and since it has already been rendered by super, do not
  // re-render the block here
  // Only if it does not contain then render the block and if there is a mainTemplate, then use its definition
  if (null != mainTemplate && mainTemplate.getBlockNames().contains("<it.id>")) {
  	mainTemplate.invokeMethod("<it.id>Block", c, w, includeTemplateMetadata);
  } else {
  	<it.id>Block(mainTemplate, c, w, includeTemplateMetadata);  
  }
}  
  <else>
  if (null != mainTemplate && mainTemplate.getBlockNames().contains("<it.id>")) {
  	mainTemplate.invokeMethod("<it.id>Block", c, w, includeTemplateMetadata);
  } else {
  	<it.id>Block(mainTemplate, c, w, includeTemplateMetadata);  
  }
  <endif>
<else>
  if (null != mainTemplate && mainTemplate.getBlockNames().contains("<it.id>")) {
  	mainTemplate.invokeMethod("<it.id>Block", c, w, includeTemplateMetadata);
  } else {
  	<it.id>Block(mainTemplate, c, w, includeTemplateMetadata);  
  }
<endif>
>>

rgroupstatement(inblock, blockname) ::= <<
<if(!inblock)>
  <if(ctxt.superClassName)>
if (!super.getRGroupNames().contains("<it.id>")) {
  // If super defines this resource group, then this template is simply overriding
  // this resource group and since it has already been rendered by super, do not
  // re-render the resource group here
  // Only if it does not contain then render the resource group and if there is a mainTemplate, then use its definition
  if (null != mainTemplate && mainTemplate.getRGroupNames().contains("<it.id>")) {
  	// When calling the main template, there is no need to specify the template parameter
	mainTemplate.invokeMethod("<it.id>RGroup", c, w, includeTemplateMetadata);
  } else {
  	<it.id>RGroup(mainTemplate, c, w, includeTemplateMetadata);
  }
} 
  <else>
  if (null != mainTemplate && mainTemplate.getRGroupNames().contains("<it.id>")) {
  	// When calling the main template, there is no need to specify the template parameter
	mainTemplate.invokeMethod("<it.id>RGroup", c, w, includeTemplateMetadata);
  } else {
  	<it.id>RGroup(mainTemplate, c, w, includeTemplateMetadata);
  }
  <endif>
<else>
  if (null != mainTemplate && mainTemplate.getRGroupNames().contains("<it.id>")) {
  	// When calling the main template, there is no need to specify the template parameter
	mainTemplate.invokeMethod("<it.id>RGroup", c, w, includeTemplateMetadata);
  } else {
  	<it.id>RGroup(mainTemplate, c, w, includeTemplateMetadata);
  }
<endif>
>>

resourcestatement(inblock, blockname) ::= <<
do {
	// Get a reference to resource in map, so that we do not preprocess a resource more than once.
	ResourceRef resRef = resRefMap.get(new ResourceRef("<it.id>", "<it.widgetName>", "<it.representationFormat>", "<it.variableName>"));
	Map\<String, String> templateInfo = null;
	if (includeTemplateMetadata) {
		templateInfo = new HashMap\<String, String>();
		templateInfo.put("templateName", TEMPLATE_NAME);	
	}
	resRef.fetchResource(c, w, templateInfo);
} while (false);	
>>

superblockstatement(inblock, blockname) ::= <<
<if(ctxt.superClassName)>
if (super.getBlockNames().contains("<it.id>")) {
	super.<it.id>Block(mainTemplate, c, w, includeTemplateMetadata);
}
<endif>
>>

superrgroupstatement(inblock, blockname) ::= <<
<if(ctxt.superClassName)>
if (super.getRGroupNames().contains("<it.id>")) {
	super.<it.id>RGroup(mainTemplate, c, w, includeTemplateMetadata);
}
<endif>
>>

includestatement(inblock, blockname) ::= <<
renderIncludedTemplate("<it.id>", c, w, includeTemplateMetadata);
>>

includeoncestatement(inblock, blockname) ::= <<
renderIncludedTemplateOnce("<it.id>", c, w, includeTemplateMetadata);
>>

conditionalstatement(inblock, blockname) ::= <<
if (<it.codedExpression>) {
	<it.ifClause.statements:{x | <x:(x.type)(inblock=inblock,blockname=blockname)>}; separator="\n">
} else {
	<it.elseClause.statements:{x | <x:(x.type)(inblock=inblock,blockname=blockname)>}; separator="\n">
}
>>

customstatement(inblock, blockname) ::= <<>>